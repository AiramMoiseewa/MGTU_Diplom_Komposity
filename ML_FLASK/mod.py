# -*- coding: utf-8 -*-
"""Файл для Flask.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1UfDE5QjkJw1zy8lgRow33yjcprKbGAQU
"""

# Commented out IPython magic to ensure Python compatibility.
import pandas as pd
import numpy as np
from sklearn.preprocessing import MinMaxScaler
from sklearn.linear_model import LinearRegression
from sklearn.model_selection import train_test_split
import pickle
import seaborn as sns
sns.set_style("darkgrid")
import matplotlib.pyplot as plt
# %matplotlib inline

import tensorflow as tf
from tensorflow import keras
from tensorflow.keras import layers
from tensorflow.keras import Sequential
from tensorflow.keras.layers import Dense, BatchNormalization, LeakyReLU, Activation, Dropout, LSTM
from keras.callbacks import EarlyStopping, ModelCheckpoint

df1 = pd.read_excel('X_bp.xlsx')
df1 = df1.rename(columns = {'Unnamed: 0':'Index'})
df1 = df1.set_index('Index')

df2 = pd.read_excel('X_nup.xlsx')
df2 = df2.rename(columns = {'Unnamed: 0':'Index'})
df2 = df2.set_index('Index')

df3 = pd.merge(df1,df2, how = 'inner', on = 'Index')
df3

#определяем X y
y_ns = np.array(df3['Соотношение матрица-наполнитель'])
X_ns = np.array(df3.drop(['Соотношение матрица-наполнитель'], axis = 1))


#train_test_split
X_train_ns, X_test_ns, y_train_ns, y_test_ns = train_test_split(X_ns, y_ns, 
                                                                test_size=0.3, 
                                                                random_state = 1)

normalizer = tf.keras.layers.Normalization(axis=-1)

X_train_ns_norm = normalizer.adapt(np.array(X_train_ns))

model_mn = Sequential(X_train_ns_norm)

model_mn.add(Dense(128))
model_mn.add(BatchNormalization())
model_mn.add(LeakyReLU())
model_mn.add(Dropout(0.18))
model_mn.add(Dense(128, activation='relu'))
model_mn.add(BatchNormalization())
model_mn.add(Dropout(0.18))
model_mn.add(Dense(64, activation='relu'))
model_mn.add(BatchNormalization())
model_mn.add(Dropout(0.18))
model_mn.add(Dense(32, activation='relu'))
model_mn.add(BatchNormalization())
model_mn.add(LeakyReLU())
model_mn.add(Dropout(0.18))
model_mn.add(Dense(16, activation='relu'))
model_mn.add(BatchNormalization())
model_mn.add(Dense(1))
model_mn.add(Activation('sigmoid'))

model_mn.compile(
                optimizer='Adam',
                loss='mean_absolute_error', 
                metrics = ['mae']
)

history = model_mn.fit( X_train_ns, 
                        y_train_ns,
                        epochs = 1, 
                        verbose = 1, 
                        validation_split = 0.2)

model_mn.summary()

model_mn.evaluate(X_train_ns, y_train_ns)

y_pred = model_mn.predict(X_test_ns[:10])
y_pred

for i in range(len(y_pred)):
  print("Сеть предсказала: ", y_pred[i], ",  верный ответ: ", y_test_ns[i], ", разница: ", y_pred[i] - y_test_ns[i])

def plot_loss(history):
    plt.plot(history.history['loss'], label = 'loss')
    plt.plot(history.history['val_loss'], label = 'val_loss')
    plt.ylim([1,3])
    plt.title('График потерь модели', size=12)
    plt.xlabel('Epochs')
    plt.ylabel('Error')
    plt.legend()
    plt.grid(True)

plot_loss(history)

"""### Сохраняем модель"""

model_mn.save('model_mn')

param_lst = [1,3,2,1,5,6,7,8,9,0,2,1]
loaded_model = keras.models.load_model("model_mn")

mod = loaded_model.predict([param_lst])

print(mod)